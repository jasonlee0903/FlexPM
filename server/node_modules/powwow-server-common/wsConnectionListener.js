'use strict';

var logger = require('./logger'),
    client = require('./client'),
    server = require('./server'),
    async = require('async'),
    browser = require('./phantomBrowser'),
    Page = require('./page');

var mainConnection = null;
var monitoringConnection = null;

var messageQueue;

var messageType = {
    REQUEST: "request",
    RESPONSE: "response",
    NOTIFICATION: "notification"
};

exports.setupConnection = function (connection) {
    // only allow one main websocket connection at a time
    if (mainConnection) {
        if (monitoringConnection != null) {
            // We already have a monitoring connection and a main connection. We'll assume the
            // new connection is also for monitoring, and will set it up that way.  If it ends
            // up being a main connection, we already can upgrade a monitoring connection to the
            // main one.
            monitoringConnection.close(4005, "Already connected");
        }
        setupMonitoringConnection(connection);
    } else {
        setupMainConnection(connection);
    }
};

exports.setupPostConnection = function(connection) {
    // Close any websocket connection.
    client.onpostconnection(connection);
    connection.once('message', function (message) {
        logger.info("Recieved a POST request");
        messageQueue.push({ connection: connection, message: message });
    });
};

exports.closePostConnection = function(connection) {
    // Close any websocket connection.
    client.onpostconnectionclose(connection);
};

function setupMainConnection(connection) {
    mainConnection = connection;

    client.onconnection(connection);
    server.onconnection(connection);

    // handle disconnection:
    connection.on('close', function () {
        logger.info('Client with address  ' + connection.remoteAddress + ' disconnected.');
        if (connection === mainConnection) {
            mainConnection = null;
        }

        server.onconnectionclose(connection);
        client.onconnectionclose(connection);
    });

    // handle message
    connection.on('message', function (message) {
        if (message.type == "utf8" && message.utf8Data == "{\"jsonrpc\":\"2.0\",\"method\":\".snapshot\",\"params\":{}}") {
            // It turns out that this is a monitoring connection.  Convert it to one.
            mainConnection.removeAllListeners();
            if (monitoringConnection) {
                monitoringConnection.close(4005, "Already connected");
            }
            setupMonitoringConnection(mainConnection);
            mainConnection = null;
            return;
        }
        messageQueue.push({ connection: connection, message: message });
    });
}

function setupMonitoringConnection(connection) {
    monitoringConnection = connection;
    monitoringConnection.on('message', function (message) {
        var parsedMessage = parseMessage(message);
        if (parsedMessage.method == ".initialize" || parsedMessage.method == ".checkstate") {
            // This wasn't opened for monitoring, it's a new connection.  Close the old one, and convert this
            // to a real connection.
            monitoringConnection.removeAllListeners();
            if (mainConnection) {
                mainConnection.close(4005, "Already connected");
            }
            setupMainConnection(monitoringConnection);
            monitoringConnection = null;
            // Push the initialize message to the queue.
            messageQueue.push({ connection: connection, message: message });
        } else if (parsedMessage.method == ".snapshot") {
            var page = browser.getMainPage();
            if (page) {
                page.renderBase64('PNG', function (err, base64) {
                    monitoringConnection.send(JSON.stringify({ url: page.getUrl(), image: base64 }));
                });
            } else {
                monitoringConnection.send(JSON.stringify({ url: "No website loaded", image: "" }));
            }
        }
    });
}

function parseMessage(message) {
    if (message.type === 'utf8') {
        var parsed = JSON.parse(message.utf8Data);
        if (parsed.jsonrpc !== '2.0') {
            throw new Error('Invalid RPC version: ' + parsed.jsonrpc);
        }

        parsed.type = getType(parsed);
        if (parsed.type == null) {
            throw new Error('Unrecognized request or response');
        }

        return parsed;
    } else {
        throw new Error('Invalid string was received by the server');
    }
};

function getType(parsed) {
    if (typeof parsed.method != 'undefined') {
        // request or notification
        if (typeof parsed.id == 'string') {
            return messageType.REQUEST;
        } else {
            return messageType.NOTIFICATION;
        }
    } else if (typeof parsed.result != 'undefined') {
        return messageType.RESPONSE;
    } else {
        // unknown
        return null;
    }
};

function handleMessage(task, callback) {
    var connection = task.connection;
    var message = task.message;

    // create a sequence to send the response
    try {
        var request = parseMessage(message);
        switch (request.type) {
            case messageType.RESPONSE:
                client.onresponse(connection, request);
                break;
            case messageType.REQUEST:
            case messageType.NOTIFICATION:
                server.onrequest(connection, request);
                break;
        }
    } catch (ex) {
        // couldn't parse message
        logger.error(ex, "Error parsing message");
    }

    callback();
};

messageQueue = async.queue(handleMessage);
