'use strict';

var fs = require('fs');
var path = require('path');
var url = require('url');
var querystring = require('querystring');
var zlib = require('zlib');
var replaceStream = require('replacestream');
var httpProxy = require('http-proxy');
var logger = require('./logger');
var config = require.main.require('./config');
var launchparams = require('./launchparams');
var wsConnectionListener = require('./wsConnectionListener');
var EventEmitter = require('events');
var http = require('http');

var proxyServer = null;
var proxyTarget = null;
var proxyHostname = null;
var postConnection = null;
var postConnectionConnected = false;

exports.initialize = function () {
    /**
     * @config httpProxy - Allows for setting up a proxy server
     */
    if (config.httpProxy) {
        logger.info("Setting up Proxy server");
        proxyServer = httpProxy.createProxyServer({
            changeOrigin: true,
            prependPath: false
        });
        if (config.httpProxy.replaceStream) {
            logger.info("Adding replace stream proxy rules.");
            proxyServer.on('proxyRes', proxyResponseHandler)
        }
    }
    /**
     * @config allowPOSTRequests - This server will listen to post requests in addition to WebSocket requests.
     */
    if (config.allowPOSTRequests) {
        logger.info("Listening to POST requests in addition to WebSocket requests.");
        // fake connection object used for handling local POST requests
        postConnection = new EventEmitter();
        postConnection.send = function (message) {
            this.emit('result', message);
        };
        postConnection.close = function(code, message) {
            this.emit('result', {"jsonrpc": "2.0","method": ".closed","params": {"message": message, "code": code}});
        };
    }
};

exports.requestListener = function (request, response) {
    logger.debug('HTTP request:',request.method, request.url);

    /**
     * The URL <http://this-server>/sourceapp or <http://this-server>?sourceapp will cause server to show a
     * source viewer.
     */
    if (request.url.indexOf("/sourceapp") == 0 || typeof url.parse(request.url, true).query.sourceapp !== 'undefined') {
        returnLocalHTMLFile('sourceapp.html', response);
        return;
    }
    /**
     * The URL <http://this-server>/test will cause a test page to show, from which you can test extracts, updates, etc.
     */
    else if (request.url.indexOf("/test") == 0) {
        returnLocalHTMLFile('test.html', response);
        return;
    } else {
        /**
         * When proxying is configured, 
         */
        var parsedUrl = getProxyRequestURL(request.url);
        if (parsedUrl) {
            var protocol = parsedUrl.protocol;
            if (parsedUrl && parsedUrl.protocol) {
                proxyTarget = parsedUrl.protocol + "//" + parsedUrl.hostname;
                proxyHostname = parsedUrl.hostname;
            }
            proxyServer.on('proxyReq', function (proxyReq, req, res) {
                proxyReq.path = parsedUrl.url;
                proxyReq.setHeader('Host', proxyHostname);
                if (config.httpProxy.addCookies) {
                    if (launchparams.cookies) {
                        var cookieString = '';
                        for (var c in launchparams.cookies) {
                            if (cookieString.length) {
                                cookieString += '; ';
                            }
                            var cookie = launchparams.cookies[c];
                            cookieString += cookie.name + '=' + cookie.value;
                        }
                        proxyReq.setHeader('Cookie', cookieString);
                    } else {
                        logger.error("There are no cookies provided that can be added to http proxy.");
                    }
                }
            });
            // Listen for the 'error' event on 'proxy'.
            proxyServer.on('error', function (err, req, res) {
                res.writeHead(200, {
                    'Content-Type': 'text/html'
                });

                res.end('<html><head>Unable to access</head><body><h2>Unable to access the requested site.</h2> <div>Please go <a href="javascript:history.go(-1)">back and try again</a>.</div></body></html>');
            });
            proxyServer.web(request, response, { target: proxyTarget });

            return;
        } else {
            if(config.customHTTPHandler && typeof config.customHTTPHandler === 'function' && config.customHTTPHandler(request, response)) {
                return;
            } else if (config.allowPOSTRequests && request.method === 'POST') {
                handlePOSTRequest(request, response);
                return;
            }
        }
        response.writeHead(404, { 'Access-Control-Allow-Origin': '*' });
        response.end();
    }
};
function getProxyRequestURL(requestUrl) {
    /**
     * @config httpProxy.urlParameter <string> - Name of URL parameter passed into this server's url that will preceed the URL to proxy.
     */
    if (config.httpProxy && config.httpProxy.urlParameter) {
        var urlObject = url.parse(requestUrl);
        var query = Object.assign({}, querystring.parse(urlObject.query));
        var urlToProxy = query[config.httpProxy.urlParameter];
        if (urlToProxy) {
            var parsedUrl = url.parse(urlToProxy);
            parsedUrl.url = requestUrl.substring(config.httpProxy.urlParameter.length+3); // Return everything after /?<urlparam>=
            return parsedUrl;
        }
    }
}

function returnLocalHTMLFile(filename, response) {
    response.writeHead(200, { 'Content-Type': 'text/html' });
    var content = fs.readFileSync(path.join(__dirname, filename), 'utf-8');
    response.end(content, 'utf-8');
}

function proxyResponseHandler(proxyRes, req, res) {
    // If we get cookies back, parse them and add them to the proxy's cookies.
    if (proxyRes.headers['set-cookie']) {
        var resCookies = proxyRes.headers['set-cookie'];
        resCookies.forEach(function(incomingCookie) {
            var cookieObj = {};
            var cookieArr = incomingCookie.split('; ');
            cookieArr.forEach(function(property, index) {
                var delimiterIndex = property.indexOf('=');
                if (index === 0) {
                    cookieObj.name = property.slice(0, delimiterIndex);
                    cookieObj.value = property.slice(delimiterIndex + 1);
                }
                if (delimiterIndex === -1) {
                    if (property === 'Secure') {
                        cookieObj.secure = true;
                    } else if (property === 'HttpOnly') {
                        cookieObj.httponly = true;
                    }
                } else {
                    if (property.slice(0, delimiterIndex) === 'Domain') {
                        cookieObj.domain = property.slice(delimiterIndex + 1);
                    } else if (property.slice(0, delimiterIndex) === 'Path') {
                        cookieObj.path = property.slice(delimiterIndex + 1);
                    }
                }
            });
            var cookieIndex = null;
            launchparams.cookies.forEach(function(oldCookie, index) {
                if (oldCookie.name === cookieObj.name) {
                    if (oldCookie.domain === cookieObj.domain) {
                        cookieIndex = index;
                    }
                }
            });
            if (cookieIndex !== null) {
                launchparams.cookies[cookieIndex] = cookieObj;
            } else {
                launchparams.cookies.push(cookieObj);
            }
        });
    }
    /**
     * @config - httpProxy.replaceStream - Array of objects that allow for rewriting the proxied sites
     *                                     content, based on the content type.  It uses the replacestream module,
     *                                     so refer to replacestream's document for usage: https://github.com/eugeneware/replacestream/tree/4.0.2
     * [
     *   {
     *     contentType <string>, - ContentType to match on
     *     search <any>, - First param to replacestream - https://github.com/eugeneware/replacestream/tree/4.0.2#examples
     *     replace <any>, - Second param to replacestream
     *     options <object> - replacestream configuration options - https://github.com/eugeneware/replacestream/tree/4.0.2#configuration
     *   }
     * ]
     */
    var arrReplaceStreamConfigs = config.httpProxy.replaceStream(req, config, launchparams);
    if (arrReplaceStreamConfigs && arrReplaceStreamConfigs.length > 0) {
        var _write = res.write;
        var _end = res.end;
        var _writeHead = res.writeHead;
        var gunzip = zlib.Gunzip();
        var firstReplaceStream = null;
        var lastReplaceStream = null;
        var replStream;

        // Assume response is uncompressed by default
        res.isGziped = false;

        res.writeHead = function (code, headers) {
            if(code == 302) {
                var baseURL = launchparams.httpServerUrl ? launchparams.httpServerUrl : "http://" + req.headers.host + "/";
                res.setHeader('Location', baseURL + '?url=' + res.getHeader("Location"));
                _writeHead.apply(res, arguments);
                return;
            }
            var contentType = this.getHeader('content-type');
            var contentEncoding = this.getHeader('content-encoding');
            var isGziped = contentEncoding && contentEncoding.toLowerCase() == 'gzip';
            var requestPath = proxyRes.req.path.toLowerCase();

            if (typeof contentType != 'undefined') {

                for (var i = arrReplaceStreamConfigs.length - 1; i >= 0; i--) {
                    var replaceStreamConfig = arrReplaceStreamConfigs[i];
                    if (contentType.indexOf(replaceStreamConfig.contentType) >= 0) {
                        logger.debug("Performing replacements on HTML file: ", requestPath);
                        replStream = replaceStream(replaceStreamConfig.search, replaceStreamConfig.replace, replaceStreamConfig.options);

                        if (firstReplaceStream == null) {
                            firstReplaceStream = lastReplaceStream = replStream;
                        } else {
                            replStream.pipe(firstReplaceStream);
                            firstReplaceStream = replStream;
                        }
                    }
                }

                if (firstReplaceStream != null) {
                    res.removeHeader('Content-Length');
                    if (headers) {
                        delete headers['content-length'];
                    }

                    if (isGziped) {
                        res.isGziped = true;
                        // Strip off the content length and content encoding since it will change.
                        res.removeHeader('Content-Encoding');
                        if (headers) {
                            delete headers['content-encoding'];
                        }
                    }
                }
                if (lastReplaceStream) {
                    lastReplaceStream.on('data', function (buf) {
                        _write.call(res, buf);
                    });
                    lastReplaceStream.on('end', function (data) {
                        _end.call(res, data);
                    });
                }
            }
            _writeHead.apply(res, arguments);
        };

        res.write = function (data, encoding) {
            // Only run data through replaceStream if we have one.
            if (firstReplaceStream) {
                if (res.isGziped) {
                    gunzip.write(data);
                } else {
                    firstReplaceStream.write(data, encoding);
                }
            } else {
                _write.apply(res, arguments);
            }
        };

        gunzip.on('data', function (buf) {
            firstReplaceStream.write(buf);
        });

        gunzip.on('end', function (data) {
            firstReplaceStream.end(data);
        });

        res.end = function (data, encoding) {
            if (firstReplaceStream) {
                if (res.isGziped) {
                    gunzip.end(data);
                } else {
                    firstReplaceStream.end(data, encoding);
                }
            } else {
                _end.apply(res, arguments);
            }
        };
    }
}

function handlePOSTRequest(request, response) {
    readData(request).then(function(data) {
        return submitData(data);
    }).then(function(result) {
        response.writeHead(200, { 
            'Access-Control-Allow-Origin': '*',
            'Content-Type': 'application/json-rpc'
        });
        response.write(result, 'utf8');
        response.end();
    });
};

// read all data from a request
function readData(request) {
    return new Promise(function(resolve, reject) {
        var buffer = "";

        request.on('data', function(data) {
            buffer += data;
        });

        request.on('end', function() {
            resolve(buffer);
        });

        request.on('error', function(error) {
            reject(error);
        });
    });
}

// write data to the post connection
function submitData(data) {
    wsConnectionListener.setupPostConnection(postConnection);
    postConnection.emit('message', {
        type: 'utf8',
        utf8Data: data
    });

    return waitForResponse();
}

// wait for a response from the post connection
function waitForResponse() {
    return new Promise(function(resolve, reject) {
        postConnection.once('result', function(message) {
            wsConnectionListener.closePostConnection(postConnection);
            resolve(message);
        });
    });
}
