var logger = require('./logger');
var stateManager = require('./stateManager');
var config = require.main.require('./config');

var previousState = null;

var stateLocked = false;
var EventEmitter = require('events').EventEmitter;
var mutationTimeout = null;
var loadTimeout = null;
var resourceLoadTimeout = null;
var timeoutStateTimeout = null;

exports.events = new EventEmitter();
exports.fieldOrActionUpdateTimeout = null;

exports.resetStateDetection = function() {
    previousState = null;
};

exports.register = function () {
    stateManager.waitForPageClosing(/.*/, function (url) {
        var page = stateManager.switchToPreviousPage();
        if (page) page.onLoadFinished('success');
    });
    
    if (config.stateDetection) {
        stateManager.register("stateDetector", /.*/, function (page, done) {
            if (loadTimeout) {
                clearTimeout(loadTimeout);
                loadTimeout = null;
            }
            loadTimeout = setTimeout(function () {
                logger.debug("State Detector: Page Loaded");

                // Set size of window and frames to prevent runaway resizing.
                if (config.viewportSize) {
                    page.resizeWindow(config.viewportSize.width, config.viewportSize.height);
                }

                if (config.stateDetection.domMutations.watch) {
                    var domMutationDebounceTime = config.stateDetection.domMutations.hasOwnProperty('debounceTime') ? config.stateDetection.domMutations.debounceTime : 100;
                    page.setMutationIgnoreList(config.stateDetection.domMutations.ignoreList
                    ).onGlobalMutation(function (data) {
                        if (mutationTimeout) {
                            clearTimeout(mutationTimeout);
                            mutationTimeout = null;
                        }
                        mutationTimeout = setTimeout(function () {
                            if(config.stateDetection.domMutations.premutationfilter) {
                                var returnVal = config.stateDetection.domMutations.premutationfilter.call(config.stateDetection.domMutations, data, previousState);
                                if(returnVal === false) {
                                    return;
                                }
                            }
                            if (config.stateDetection.domMutations.loggedNodesLength) {
                               var subData = config.stateDetection.domMutations.loggedNodesLength == -1 ? data : data.substring(data.length - config.stateDetection.domMutations.loggedNodesLength);
                                subData = subData.replace(/\s/g, " ");
                                logger.info("State Detector DOM Mutation:", subData);
                            }
                            exports.checkState(page, data);
                        }, domMutationDebounceTime);
                    }, true);
                }

                // Check state in case we had DOM mutations before mutation handler was set up.
                setTimeout(function () {
                    if (config.stateDetection.resourceLoads.watch) {
                        var resourceLoadDebounceTime = config.stateDetection.resourceLoads.hasOwnProperty('debounceTime') ? config.stateDetection.resourceLoads.debounceTime : 200;
                        stateManager.registerResourceLoad("stateDetector", /.*/, function (response) {
                            if (response.contentType) {
                                var checkStateOnResourceLoad = false;
                                for (var i = 0; i < config.stateDetection.resourceLoads.checkList.length; i++) {
                                    if (response.contentType.indexOf(config.stateDetection.resourceLoads.checkList[i]) >= 0) {
                                        checkStateOnResourceLoad = true;
                                    }
                                }
                                if (!checkStateOnResourceLoad) {
                                    // Don't do a resource load check.
                                    logger.debug("State Detector Ignoring content type:", response.contentType);
                                    return;
                                }

                                logger.info("State Detector watched resource has loaded:", response.contentType);
                                if (resourceLoadTimeout) {
                                    clearTimeout(resourceLoadTimeout);
                                    resourceLoadTimeout = null;
                                }
                                resourceLoadTimeout = setTimeout(function () {
                                    try {
                                        exports.checkState(page);
                                    } catch (e) {
                                        logger.error(e);
                                    }
                                }, resourceLoadDebounceTime);
                            } else {
                                logger.info("State Detector loaded resource without content type");
                            }
                        });
                    }

                    exports.checkState(page);
                }, config.stateDetection.hasOwnProperty('stateCheckTimeAfterMutationHandler') ? config.stateDetection.stateCheckTimeAfterMutationHandler : 200);
            }, config.stateDetection.hasOwnProperty('detectTimeAfterLoad') ? config.stateDetection.detectTimeAfterLoad : 500);
        });
    }
};

exports.checkState = function (page, data, force) {
    if (exports.fieldOrActionUpdateTimeout) {
        clearTimeout(exports.fieldOrActionUpdateTimeout);
        exports.fieldOrActionUpdateTimeout = null;
    }
    page.checkStateUsingDescriptor()
        .then(function (connection) {
            if (connection) {
                try {
                    var state = connection.mainModel + "." + connection.name;
                    if (previousState == null) {
                        if (config.stateDetection.startState) {
                            if (!state.match(config.stateDetection.startState)) {
                                return;
                            }
                        }
                        logger.info("** Initial state: ->", state);
                    } else {
                        logger.info("** State change:", previousState, "->", state);
                    }

                    if (!stateLocked) {
                        if (previousState === state && !force) {
                            if ((connection.model || connection.mainModel) && connection.screens) {
                                if (screenMatches(stateManager.getScreen(), connection.screens)) {
                                    logger.info("Screen is same, checking if data has changed.");
                                    // Check if actual state is the same.
                                    var currentStateData = stateManager.getCurrentScreen().params;
                                    page.extractAndTest(connection.model || connection.mainModel, function (extractedData) {
                                        if (dataHasBeenUpdated(currentStateData, extractedData)) {
                                            logger.info("Data has change, re-evaluating state");
                                            changeState(state, page, connection, stateManager.getScreen());
                                        }
                                        else if(config.stateDetection.changeWhenRequestInProgress && stateManager.isRequestInProgress()) {
                                            logger.info("Request is in progress, re-evaluating state");
                                            changeState(state, page, connection, stateManager.getScreen());
                                        }
                                    });
                                } else {
                                    logger.debug("State hasn't changed and we aren't on the same screen.  Do nothing.")
                                }
                            } else {
                                logger.debug("State hasn't changed and no model & screens.  Doing nothing.")
                            }
                            return;
                        }
                        previousState = state;
                        page.clearData();

                        // If state is null, wait some time before changing to it...
                        if (timeoutStateTimeout) {
                            clearTimeout(timeoutStateTimeout);
                            timeoutStateTimeout = null;
                        }

                        if (config.stateDetection.timeouts && config.stateDetection.timeouts.hasOwnProperty(state)) {
                            logger.info("Waiting for", config.stateDetection.timeouts[state], "ms before changing state.");
                            timeoutStateTimeout = setTimeout(function () {
                                changeState(state, page, connection);
                            }, config.stateDetection.timeouts[state]);
                        } else {
                            changeState(state, page, connection);
                        }
                    } else {
                        logger.info("State is locked, ignoring state change.");
                        exports.events.emit('newState', state, data);
                    }
                }
                catch (e) {
                    logger.error(e);
                }
            } else {
                logger.info("No state detected. Check for missing identifiers or connections.");
            }
        });
};

exports.lockState = function () {
    exports.events.removeAllListeners('newState');
    stateLocked = true;
};

exports.unlockState = function () {
    stateLocked = false;
    exports.events.removeAllListeners('newState');
};

function changeState(state, page, connection, currentScreen) {
    var api = require.main.require('./api');

    logger.info("State detector processing connection:", state);
    var namespace = connection.mainModel;
    var model = (connection.model || connection.mainModel);
    if (connection.event) {
        var action = "on_" + connection.event;
        if (typeof api[namespace] === 'object' && typeof api[namespace][action] === 'function') {
            logger.info("Found ", namespace + "." + action);
            try {
                api[namespace][action].call(api[namespace], page);
            } catch (e) {
                logger.error(e.message);
            }
        } else {
            logger.info('*** Event method does not exist: ' + namespace + "." + action);
        }
    } else if (connection.screens) {
        if (model && connection.screens && connection.screens.length > 0) {
            page.clearData()
                .extract(model)
                .screen(currentScreen ? currentScreen : connection.screens[0]);
        }
    } else if (connection.action) {
        if (model) {
            page.action(model, connection.action);
        }
    }
}

function screenMatches(screenName, arrScreens) {
    for (var i = 0; i < arrScreens.length; i++) {
        if (screenName == arrScreens[i]) {
            return true;
        }
    }
    return false;
}

function isArray(item) {
    var type = toString.call(item);
    return (type.indexOf("Array]") >= 0 || type.indexOf("NodeList]") >= 0);
}

function isObject(item) {
    var type = toString.call(item);
    return type === "[object Object]";
}

function dataHasBeenUpdated(oldValue, newValue) {
    if (isArray(newValue)) {
        // If old value isn't an array or doesn't have the same length, we have an update...
        if (!isArray(oldValue) || newValue.length !== oldValue.length) {
            return true;
        }
        for (var i = 0; i < newValue.length; i++) {
            if (dataHasBeenUpdated(oldValue[i], newValue[i])) {
                return true;
            }
        }
    } else if (isObject(newValue)) {
        var newKeys = Object.keys(newValue);
        if (!isObject(oldValue)) {
            return true;
        } else {
            var oldKeys = Object.keys(oldValue);
            if (newKeys.length > oldKeys.length) {
                return true;
            }
        }
        for (var i = 0; i < newKeys.length; i++) {
            if (dataHasBeenUpdated(oldValue[newKeys[i]], newValue[newKeys[i]])) {
                return true;
            }
        }
    } else {
        if (oldValue !== newValue) {
            return true;
        }
    }
    return false;
}
