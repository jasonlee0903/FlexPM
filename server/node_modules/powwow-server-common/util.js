'use strict';

var moment = require('moment');
var fs = require('fs');

var config = require.main.require('./config');

var logger = require('./logger');
var stateManager = require('./stateManager');
var browser = require('./phantomBrowser');
var stateDetector = require('./stateDetector');

exports.initialize = function (params) {
    if (config.initialize) {
        // Special method to call initialization method on the config object.
        var initializeMethodReturn = config.initialize.call(config, params);
        if (config.initializeReturnsPromise) {
            logger.info("config.initialize returned a promise");
            initializeMethodReturn.then(function (val) {
                stateManager.initializeConnection(val);
            }, function (err) {
                stateManager.setScreen("error", err);
            });
        } else {
            //logger.info("Initialize method returns immediately");
            stateManager.initializeConnection(initializeMethodReturn);
        }
    } else {
        logger.info("config.initialize not found");
        stateManager.initializeConnection();
    }
};

exports.checkstate = function (params) {
    stateManager.checkstate();
};

// API call to update a field on an onchange event.
// Input should be of form:
// {
//     model: "mainform",
//     dynamic: true,
//     timeout: 2000,
//     data : {
//        "section1.address": "123 Main St."
//     }
// }
exports.update = function (page, params) {

    stateManager.updateCurrentScreenData(params.data);

    if (params.dynamic) {
        // We are expecting a DOM mutation to pick up the change,
        // but if it doesn't happen, we will wait for the update
        // timeout and then do a check state.
        page.update(params.model, params.data)
            .run(function () {
                if (params.timeout) {
                    stateDetector.fieldOrActionUpdateTimeout = setTimeout(function () {
                        stateDetector.checkState(page);
                    }, params.timeout);
                }
            });
    } else {
        // This isn't a dynamic field, so we do an update and then
        // an immediate check state.
        page.update(params.model, params.data)
            .run(function () {
                stateDetector.checkState(page);
            });
    }
};

// API call to call an action.
// Passes in the model, the action to call and the data to update.
// {
//     model: "login",
//     action: "mainform.submit",
//     timeout: 2000, // There is a possiblity that action won't do anything, in which case do a check state after some time.
//     data: {
//         "mainform.username": "Administrator"
//         "mainform.password": "iamgod"
//     }
// }
exports.action = function (page, params) {

    stateManager.updateCurrentScreenData(params.data);

    page.update(params.model, params.data)
        .action(params.model, params.action)
        .run(function () {
            if (params.timeout) {
                stateDetector.fieldOrActionUpdateTimeout = setTimeout(function () {
                    stateDetector.checkState(page);
                }, params.timeout);
            }
        });
};

// API call to switch screens.  If a model is passed in, an extract will be done.
// If a model is not passed in, the existing current state data will be used.
// {
//   model: "login",
//   screen: "login/login2"
// }
exports.screen = function (page, params) {
    if (params.model) {
        page.extract(params.model)
            .screen(params.screen);
    } else {
        var currentStateData = stateManager.getCurrentScreen().params;
        stateManager.setScreen(params.screen, currentStateData);
    }
}

exports.logException = function (page, params) {
    // There was a client side exception.  Exception details are already logged in log file, so no need
    // to do anything here.
};

/*
 * Method to report issues on app hang by taking and saving a snapshot and dumping the HTML file
 */
exports.reportIssue = function (page, params) {
    logger.debug("util.reportIssues");

    //Create root folder as required
    var sbRoot = './Snapshots';
    var fileHTML = sbRoot + "/" + moment().format("MMDDYY-HHmmss") + "-HTML" + ".html";
    var fileSnapshot = sbRoot + "/" + moment().format("MMDDYY-HHmmss") + "-snapshot" + ".png";

    if (!fs.existsSync(sbRoot)) {
        fs.mkdirSync(sbRoot);
    }

    page.render(fileSnapshot)
        .evalSync(function () {
            var doc = (window.document) ? document.body.outerHTML : 'No window.document';
            return JSON.stringify({ document: doc });
        })
        .data(function (data) {
            fs.writeFile(fileHTML, data.document, function (err) {
                if (err) {
                    return logger.info("Error dumping HTML", err);
                }
            });
        })
        .checkState();
};

exports.logRequest = function (request) {
    var method, methodData;
    if (request.method == '.action') {
        method = request.params.model + "." + request.params.action;
        methodData = {
            action: true,
            params: filterLogParams(method, request.params.data)
        };
        if (request.params.timeout) {
            params = request.params.timeout;
        }
    } else if (request.method == '.update') {
        var method = request.params.model + ".update_" + Object.keys(request.params.data).join("_");
        var methodData = {
            params: filterLogParams(method, request.params.data)
        };
        if (request.params.hasOwnProperty('dynamic')) {
            methodData.dynamic = request.params.dynamic;
        }
        if (request.params.hasOwnProperty('timeout')) {
            methodData.timeout = request.params.timeout;
        }
    } else {
        method = request.method;
        methodData = {
            params: filterLogParams(request.method, request.params)
        };
    }
    logger.info("<== " + method, methodData);
};

exports.logResponse = function (method, params) {
    // If config file doesn't say to fully log this response, cut it off after 80 chars.
    var logParamSize = 80;
    if (config.log && config.log.paramSizeFilters && config.log.paramSizeFilters.hasOwnProperty(method)) {
        logParamSize = config.log.paramSizeFilters[method];
    }

    if (params && logParamSize != 0) {
        var loggedParams = JSON.stringify(params);
        if (logParamSize > 0) {
            loggedParams = loggedParams.substring(0, logParamSize);
        }
        logger.info('==> ' + method + " " + loggedParams);
    } else {
        logger.info('==> ' + method);
    }
};

function filterLogParams(method, params) {
    if (config.log.logFilters) {
        var paramsToFilter = config.log.logFilters[method];
        if (paramsToFilter) {
            var logParams = {};
            for (var prop in params) {
                if (paramsToFilter.indexOf(prop) == -1) {
                    logParams[prop] = params[prop];
                }
            }
            return logParams;
        }
    }
    return params;
}
